# This workflow will build and push a new container image to Amazon ECR,
# and then will deploy a new task definition to Amazon ECS, when there is a push to the "main" branch.
#
# To use this workflow, you will need to complete the following set-up steps:
#
# 1. Create an ECR repository to store your images.
#    For example: `aws ecr create-repository --repository-name my-ecr-repo --region us-east-2`.
#    Replace the value of the `ECR_REPOSITORY` environment variable in the workflow below with your repository's name.
#    Replace the value of the `AWS_REGION` environment variable in the workflow below with your repository's region.
#
# 2. Create an ECS task definition, an ECS cluster, and an ECS service.
#    For example, follow the Getting Started guide on the ECS console:
#      https://us-east-2.console.aws.amazon.com/ecs/home?region=us-east-2#/firstRun
#    Replace the value of the `ECS_SERVICE` environment variable in the workflow below with the name you set for the Amazon ECS service.
#    Replace the value of the `ECS_CLUSTER` environment variable in the workflow below with the name you set for the cluster.
#
# 3. Store your ECS task definition as a JSON file in your repository.
#    The format should follow the output of `aws ecs register-task-definition --generate-cli-skeleton`.
#    Replace the value of the `ECS_TASK_DEFINITION` environment variable in the workflow below with the path to the JSON file.
#    Replace the value of the `CONTAINER_NAME` environment variable in the workflow below with the name of the container
#    in the `containerDefinitions` section of the task definition.
#
# 4. Store an IAM user access key in GitHub Actions secrets named `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY`.
#    See the documentation for each action used below for the recommended IAM policies for this IAM user,
#    and best practices on handling the access key credentials.

name: Deploy to Amazon ECS

on:
  push:
    branches: [ "main" ]

env:
  QT_VERSION: 6.4.3
  AWS_REGION: eu-west-3                             # set this to your preferred AWS region, e.g. us-west-1
  ECR_REPOSITORY: eventpay-ecr-repository           # set this to your Amazon ECR repository name
  ECS_SERVICE: MY_ECS_SERVICE                 # set this to your Amazon ECS service name
  ECS_CLUSTER: EventPayCluster                      # set this to your Amazon ECS cluster name
  ECS_TASK_DEFINITION: /home/runner/work/Runner/Runner/tb_core/aws/taskDefinition.json # set this to the path to your Amazon ECS task definition
                                               # file, e.g. .aws/task-definition.json
  CONTAINER_NAME: api-service           # set this to the name of the container in the
  RELEASE_REVISION: "pr-${{ github.event.pull_request.number }}-${{ github.event.pull_request.head.sha }}"
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  KUBE_CONFIG_DATA: ${{ secrets.KUBE_CONFIG_DATA }}
  KUBE_NAMESPACE: production

permissions:
  contents: read

jobs:
  deploy:
    name: Deploy
    runs-on: ubuntu-latest
    environment: production

    steps:
    - name: Checkout
      uses: actions/checkout@v3
      with:
          path: source
          submodules: recursive
          fetch-depth: 0
      
    - name: Setup ninja
      uses: seanmiddleditch/gha-setup-ninja@v3
        
    - name: Download Qt (desktop)
      id: qt-desktop
      uses: jurplel/install-qt-action@v3
      with:
        aqtversion: ==2.1.*
        version: ${{ env.QT_VERSION }}
        modules: 'qthttpserver qtwebsockets'
        set-env: true

    - name: Setup SSH
      uses: MrSquaare/ssh-setup-action@v1
      with:
          host: github.com
          private-key: ${{ secrets.SSH_PRIVATE_KEY }}

    - name: Cloning EventPay switching to develop
      working-directory: source
      run: |
        cd ..
        git clone git@github.com:TokenBar/tb_core.git
        cd tb_core
        git checkout develop
        cd ../source
        
    - name: Build (Release)
      working-directory: source
      run: |
        cd ../tb_core
        cmake -DCMAKE_BUILD_TYPE=Release -S . -B "./build"
        cmake --build ./build
        
    - name: Build (Release)
      working-directory: source
      run: |
        cd ../tb_core
        cd build
        pwd
        ls

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1
      
    - name: Set up Docker Buildx                             
      id: buildx                                             
      uses: docker/setup-buildx-action@master                
    - name: Docker cache layers                              
      uses: actions/cache@v2                                 
      with:                                                  
        path: /tmp/.buildx-cache                             
        key: ${{ runner.os }}-single-buildx-${{ github.sha }}
        restore-keys: |                                      
          ${{ runner.os }}-single-buildx  
          
    - name: Build & Push Image     
      working-directory: tb_core
      env:                                                                                                          
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}                                                       
        RELEASE_IMAGE: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ env.RELEASE_REVISION }}
      run: |
        docker buildx create --use

        docker buildx build \                                
          --cache-from=type=local,src=/tmp/.buildx-cache \   
          --cache-to=type=local,dest=/tmp/.buildx-cache-new \
          --tag ${{ env.RELEASE_IMAGE }} \                           
          --target release \                                 
          --push \                                           
          .                                                  

        rm -rf /tmp/.buildx-cache
        mv /tmp/.buildx-cache-new /tmp/.buildx-cache

    - name: Deploy to Kubernetes cluster                                                                            
      uses: kodermax/kubectl-aws-eks@master                                                                         
      env:                                                                                                          
        RELEASE_IMAGE: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ env.RELEASE_REVISION }}
      with:                                                                                                         
        args: set image deployment/my-pod app=${{ env.RELEASE_IMAGE }} --record -n $KUBE_NAMESPACE   
        
    - name: Verify Kubernetes deployment                               
      uses: kodermax/kubectl-aws-eks@master                            
      with:                                                            
        args: rollout status deploy my-pod -n $KUBE_NAMESPACE 
